---
title: "Clock In & Out Analysis"
author: "Tino Muzambi"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
library(lubridate)
library(plotly)
library(DT)
```

# Introduction

Towards the end of 2023 I applied and got accepted into the MSc Data Science program at the University of Cape Town. It was this new journey that inspired me to embark on a little side project of my own. The idea behind the project was to pursue a task that would involve all stages of the data analysis pipeline. From  data collection, to data cleaning, to visualising the data and finally using it to tell a story. I also envisioned it as an opportunity to put into practical practice what I would've learned throughout the year as part of my MSc.

I chose the focus of my project to be analysing the times I clocked in and out at the office. I figured this would be interesting to analyse especially considering that as part of my MSc I would have lectures that would sometimes eat into my usual working hours. That coupled with other commitments that come up in life sounded like it would make for an interesting analysis and that's how this project was born.

This notebook demonstrates how I went about cleaning, analysing and plotting the data. A more detailed post will follow on [my blog](https://blog.tinomuzambi.com) which will delve more into the data collection process and follow a more storytelling narrative.

# Read in data
The data come from a Notion database as a CSV and contain fields for the date of interest, the time I clocked in and out respectively on said date and any notes detailing anything of interest that occurred on said date e.g a lecture, a pre-work commitment, a conference, etcetera.

We begin by reading in the data and preventing automatic casting as this leads to the time fields being cast to a `difftime` object which, for our purposes isn't conducive for analysis. Therefore we use the `col_types` argument to retain all data as character vectors. We also convert the data to a tibble for the [nice qualities](https:://link.com) that tibbles provide.
```{r read data}
# Read data
data <- read_csv("data/data.csv", col_types = "cccc") %>% as_tibble()

# View data
head(data)
```

```{r}
# Structure of the data
str(data)
```

```{r}
unique(data$Notes)
```


The data contain 250 entries where each entry is a day and all fields are stored as character vectors. The notes field is a multi-select field and the various options for it are a comma separated character vector of any number of the following:

  - Work from home
  - Pre-work commitment
  - Post-work commitment
  - Annual leave
  - Sick leave
  - Study leave
  - Public holiday
  - Conference
  - 11:00 lecture
  - 14:00 lecture
  - 16:00 lecture

Days with the any of work from home, annual leave, sick leave, public holiday and conference will likely not have any clock in/out times since I won't go into the office during these occasions.

# Prepare data for analysis
In order to prepare the data for analysis, a few cleaning steps are necessary. We begin by renaming the columns to make them easier to work with and more representative of the data they represent.

```{r rename columns}
# Rename columns
data <- data %>% rename(
  date = Date,
  clock.in = "Clock In Time",
  clock.out = "Clock Out Time",
  event = Notes
)

data
```

We also add an ID column to make identifying rows easier.
```{r id column}
# Add id column
data <- data %>% 
  mutate(id = rownames(data))

data
```

We then manually cast fields to appropriate data types. Here we take advantage of lubridate's excellent datetime casting capabilities. We use the `parse_date_time` function to cast both the date and clock in/out time fields displaying the versatility of this function and this library. This casts the fields into POSIXct class which allows us to perform various datetime functions on them. However, here we run into a characteristic of R that's less than ideal.

When working with dates and times in R, the aforementioned POSIXct class is used and this class mandates having both a date portion and a time portion. This means that date fields are required to have some arbitrary time portion and similarly time fields are required to have some arbitrary date portion. This is why you'll often see time fields beginning with 1970-01-01. TODO: explain more. This ultimately has no effect on functionality but is just a nuisance when it comes to displaying as it requires reformatting to exclude the unwanted portion.
```{r cast}
# Cast date, clock.in and clock.out using lubridate
data <- data %>% 
  mutate(date = parse_date_time(date, orders = "dmy"),
         clock.in = parse_date_time(clock.in, orders = "%H:%M"),
         clock.out = parse_date_time(clock.out, orders = "%H:%M"),
         # Convert events to programmatically friendly strings
         event = gsub(" ", "_", event),
         event = gsub(":", "_", event),
         event = gsub("-", "_", event),
         # Replace NA events
         event = replace(event, is.na(event), "Standard"))

data
```

# Tidy data
With those basic steps complete, we now begin moving towards getting the data into a "tidy" format. Tidy data is a standard way of structuring data that makes it easier to analyze, visualize, and model. The key principle of tidy data is that each variable forms a *column*, each observation forms a *row*, and each type of observational unit forms a *table*.

We will begin by dealing with the event column by extracting the different possible events into their own columns.
```{r separate}
# Separate options from event into separate columns
data.tidy <- data %>% separate_rows(event, sep = ",_")

data.tidy %>% filter(id == 24)
```

```{r indicator columns}
# Create indicator columns for event options
data.tidy <- data.tidy %>% 
  mutate(event_Work_from_home = if_else(event == "Work_from_home", TRUE, FALSE),
         event_Post_Work_Commitment = if_else(event == "Post_Work_Commitment", TRUE, FALSE),
         event_Pre_Work_Commitment = if_else(event == "Pre_Work_Commitment", TRUE, FALSE),
         event_16_00_lecture = if_else(event == "16_00_lecture", TRUE, FALSE),
         event_14_00_lecture = if_else(event == "14_00_lecture", TRUE, FALSE),
         event_11_00_lecture = if_else(event == "11_00_lecture", TRUE, FALSE),
         event_Annual_leave = if_else(event == "Annual_leave", TRUE, FALSE),
         event_Sick_leave = if_else(event == "Sick_leave", TRUE, FALSE),
         event_Study_leave = if_else(event == "Study_leave", TRUE, FALSE),
         event_Public_Holiday = if_else(event == "Public_Holiday", TRUE, FALSE),
         event_Conference = if_else(event == "Conference", TRUE, FALSE))

data.tidy %>% select(starts_with("event_"))
```

```{r replace nas}
# Replace NAs with 0s in indicator columns
data.tidy <- data.tidy %>% 
  mutate(across(starts_with("event_"), ~
                  replace(., is.na(.), 0)))

data.tidy %>% select(starts_with("event_"))
```

```{r collapse}
# Collapse into original number of rows
data.collapsed <- data.tidy %>% 
  group_by(id) %>% 
  summarise(
    event_Work_from_home = max(event_Work_from_home),
    event_Post_Work_Commitment = max(event_Post_Work_Commitment),
    event_Pre_Work_Commitment = max(event_Pre_Work_Commitment),
    event_16_00_lecture = max(event_16_00_lecture),
    event_14_00_lecture = max(event_14_00_lecture),
    event_11_00_lecture = max(event_11_00_lecture),
    event_Annual_leave = max(event_Annual_leave),
    event_Sick_leave = max(event_Sick_leave),
    event_Study_leave = max(event_Study_leave),
    event_Public_Holiday = max(event_Public_Holiday),
    event_Conference = max(event_Conference),
    .groups = "drop"
  )

data.collapsed
```

```{r combine}
# Combine dataframes
data.combined <- full_join(data.collapsed, data)

data.combined
```

# Compile summaries of data
```{r pivot longer}
# Pivot longer
data.long <- data.combined %>%
  gather(key = "event.type",
         value = "time", clock.in, clock.out) %>% 
  mutate(event.type = ifelse(event.type == "clock.in", 
                             "Clock In", "Clock Out"),
         event = str_split(event, ",_")) %>% 
  unnest(event)
```

```{r time summaries}
# Get per event summaries
time.summaries <- data.long %>% group_by(event, event.type) %>% 
  summarise(
    n = n(),
    mean.time = format(mean(time, na.rm = T), "%H:%M"),
  )

datatable(time.summaries)
```

# Overall mean times
```{r time summary function}
time.summary <- function(time.field) {
  # Ensure the input is in POSIXct format
  time.field <- as.POSIXct(time.field, format = "%H:%M")
  
  # Sort times
  sorted.times <- sort(time.field)
  
  # Calculate minimum and maximum
  min.time <- min(time.field, na.rm = T)
  max.time <- max(time.field, na.rm = T)
  
  # Calculate median
  median.time <- median(time.field, na.rm = T)
  
  # Calculate mode
  mode.time <- as.POSIXct(names(sort(table(sorted.times), decreasing = T)[1]), origin = "0000-01-01", tz = "UTC")
  
  # Calculate mean
  mean.time <- mean(time.field, na.rm = T)
  
  # Compile output
  formatted.summary <- tibble(
    statistic = c("Min", "Max", "Median", "Mode", "Mean"),
    time = c(format(min.time, "%H:%M"),
              format(max.time, "%H:%M"),
              format(median.time, "%H:%M"),
              format(mode.time, "%H:%M"),
              format(mean.time, "%H:%M"))
  )
  
  return(formatted.summary)
}
```


```{r clock in summary}
# Clock in summary
clock.in.summary <- time.summary(data$clock.in)
datatable(clock.in.summary)
```

```{r clock out summary}
clock.out.summary <- time.summary(data$clock.out)
datatable(clock.out.summary)
```

```{r mean office time}
# Mean time spent at office
mean.clock.in <- parse_date_time(clock.in.summary$time[5], orders = "%H:%M")
mean.clock.out <- parse_date_time(clock.out.summary$time[5], orders = "%H:%M")

mean.office.time <- mean.clock.out - mean.clock.in
mean.office.time
```

# Plot some graphs
```{r line graph, fig.width=12, fig.height=6, out.width="100%", out.height="auto"}
# Line graph of clock in and out times
ggplot(data.combined,
       aes(x = date)) +
  geom_line(aes(y = clock.in, color = "Clock In"), linewidth = 1, na.rm = T) +
  geom_line(aes(y = clock.out, color = "Clock Out"), linewidth = 1, na.rm = T) +
  scale_color_manual(values = c("Clock In" = "blue", "Clock Out" = "red")) +
  labs(title = "Clock in and Clock Out Times for 2024",
       x = "Date",
       y = "Time",
       color = "Legend") +
  theme_minimal() +
  theme(legend.position = "bottom", plot.title = element_text(hjust = 0.5))
```

```{r scatter plot, fig.width=12, fig.height=6, out.width="100%", out.height="auto"}
# Scatter plot of clock in and out times
ggplot(data.combined,
       aes(x = date)) +
  geom_point(aes(y = clock.in, color = "Clock In"), na.rm = T) +
  geom_point(aes(y = clock.out, color = "Clock Out"), na.rm = T) +
  scale_color_manual(values = c("Clock In" = "blue", "Clock Out" = "red")) +
  labs(title = "Clock in and Clock Out Times for 2024",
       x = "Date",
       y = "Time",
       color = "Legend") +
  theme_minimal() +
  theme(legend.position = "bottom", plot.title = element_text(hjust = 0.5))
```

```{r detailed scatter plot, fig.width=12, fig.height=6, out.width="100%", out.height="auto"}
# Plot more detailed plot
clock.in.out.detail <- ggplot(data.long, aes(x = date, y = time, colour = event, fill = event, shape = event.type)) +
  geom_jitter(size = 3, width = 1, height = 1, alpha = 0.7, na.rm = T) +
  scale_color_manual(values = c("Post_Work_Commitment" = "green",
                   "Pre_Work_Commitment" = "grey", "16_00_lecture" = "blue", "14_00_lecture" = "red", "11_00_lecture" = "black",
                   "Study_leave" = "yellow", "Conference" = "purple","Standard" = "orange"),
                   labels = c("Work_from_home" = "Work from home", "Post_Work_Commitment" = "Post-work commitment",
                   "Pre_Work_Commitment" = "Post-work commitment", "16_00_lecture" = "16:00 lecture", "14_00_lecture" = "14:00 lecture",
                   "Public_Holiday" = "Public holiday", "Annual_leave" = "Annual leave", "11_00_lecture" = "11:00 lecture",
                   "Study_leave" = "Study leave", "Conference" = "Conference", "Sick_leave" = "Sick leave", "Standard" = "Standard")) + 
  scale_fill_manual(values = c("Post_Work_Commitment" = "green",
                   "Pre_Work_Commitment" = "grey", "16_00_lecture" = "blue", "14_00_lecture" = "red", "11_00_lecture" = "black",
                   "Study_leave" = "yellow", "Conference" = "purple","Standard" = "orange"),
                   labels = c("Work_from_home" = "Work from home", "Post_Work_Commitment" = "Post-work commitment",
                   "Pre_Work_Commitment" = "Post-work commitment", "16_00_lecture" = "16:00 lecture", "14_00_lecture" = "14:00 lecture",
                   "Public_Holiday" = "Public holiday", "Annual_leave" = "Annual leave", "11_00_lecture" = "11:00 lecture",
                   "Study_leave" = "Study leave", "Conference" = "Conference", "Sick_leave" = "Sick leave", "Standard" = "Standard")) +
  scale_shape_manual(values = c("Clock In" = 24, "Clock Out" = 25)) +
  labs(title = "Clock in and Clock Out Times for 2024",
       x = "Date",
       y = "Time",
       color = "Event",
       fill = "Event",
       shape = "Event Type") +
  theme_minimal() +
  theme(legend.position = "bottom", plot.title = element_text(hjust = 0.5))
# ggplotly(clock.in.out.detail)
clock.in.out.detail
```

```{r scatter mean times, fig.width=12, fig.height=6, out.width="100%", out.height="auto"}
# Add mean times to plot
clock.in.out.detail + 
  geom_hline(yintercept = mean.clock.in, color = "blue", linetype = "dashed") + 
  geom_hline(yintercept = mean.clock.out, color = "red", linetype = "dashed") +
  geom_text(aes(x = as.POSIXct("2024-01-01"), y = mean.clock.in, label = paste(format(mean.clock.in, "%H:%M"))), color = "blue", vjust = -0.5, hjust = 1.2) + 
  geom_text(aes(x = as.POSIXct("2024-01-01"), y = mean.clock.out, label = paste(format(mean.clock.out, "%H:%M"))), color = "red", vjust = -0.5, hjust = 1.2) 
```

# References

  - Wickham, H. (2014). *Tidy Data*. *Journal of Statistical Software*, 59(10), 1-23. [https://www.jstatsoft.org/article/view/v059i10](https://www.jstatsoft.org/article/view/v059i10)